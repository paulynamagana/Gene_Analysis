---
title: "GSE32863, Microarray of lung adenocarcinoma: nov22"
author: "Paulyna Magana"
output:
  pdf_document:
    toc: true
    toc_depth: 2
    number_sections: true
    fig_width: 6
    fig_height: 8
    fig_caption: true
header-includes:
- \usepackage{gb4e}
- \noautomath

always_allow_html: true

knit: (function(input_file, encoding) { output_dir = "./";
  rmarkdown::render(input_file,
 encoding=encoding,
 output_file=file.path(dirname(input_file), output_dir, 'GSE32863_analysis_results'))})
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
```

## R Markdown

```{r importing, message=FALSE, warning=FALSE}

library(dplyr)
library(limma)
library(tinytex)
library(edgeR)
library(Biobase)
readr::local_edition(1)
library(GEOquery)

my_id <- "GSE32863"

## extract geo expression, fData, eData
Sys.setenv(VROOM_CONNECTION_SIZE = 256000000)
expr <- getGEO(my_id)[[1]]

sampleInfo <- pData(expr)
edata <- exprs(expr) #to compare the edata matrix to the raw data that I'll obtain later
annot <- fData(expr) #annotation data


print(expr@experimentData)

```

## load files

```{r}
baseDir <- "./"
bgxfile <- "GPL6884_HumanWG-6_V3_0_R0_11282955_A.bgx"
targetsfile <- 'targets.txt'

options(scipen = 99)
require(limma)
require(RColorBrewer)
require(PCAtools)
```

```{r}
# read in the data and convert the data to an EListRaw object, which is a data object for single channel data
x <- read.table(paste0(baseDir, 'GSE32863_non-normalized.txt.gz'),
    header = TRUE, sep = '\t', stringsAsFactors = FALSE, skip = 0)

# update the target info
targetinfo <- readTargets(targetsfile, sep = '\t')

rownames(targetinfo) <- targetinfo$IDATfile

detectionpvalues <- x[,grep('Detection.Pval', colnames(x))]

x <- x[,-grep('Detection.Pval', colnames(x))]

probes <- x$ID_REF

x <- data.matrix(x[,2:ncol(x)])

rownames(x) <- probes

colnames(x) <- targetinfo$IDATfile
colnames(detectionpvalues) <- colnames(x)


x <- x[,match(rownames(targetinfo), colnames(x))]

if (!all(colnames(x) == rownames(targetinfo)))
  stop('Target info is not aligned to expression data - they must be in the same order')
```



```{r}
# read in annotation

annot <- illuminaio::readBGX(bgxfile)$probes

annot <- annot[,which(colnames(annot) %in% c('Source','Symbol','Transcript','ILMN_Gene','RefSeq_ID',
    'Entrez_Gene_ID','Symbol','Protein_Product','Probe_Id','Probe_Type',
    'Probe_Start','Chromosome','Probe_Chr_Orientation','Probe_Coordinates',
    'Cytoband', 'Definition', 'Ontology_Component', 'Ontology_Process',
    'Ontology_Function', 'Synonyms'))]

annot <- annot[which(annot$Probe_Id %in% rownames(x)),]

annot <- annot[match(rownames(x), annot$Probe_Id),]
```




```{r warning=FALSE}
# create a custom EListRaw object
project <- new('EListRaw')
project@.Data[[1]] <- 'illumina'
project@.Data[[2]] <- targetinfo

#project@.Data[[3]] <- annot
project@.Data[[3]] <- NULL
project@.Data[[4]] <- x
project@.Data[[5]] <- NULL
project$E <- x
project$targets <- targetinfo
#project$genes <- annot
project$genes <- NULL
project$other$detection <- detectionpvalues

```



```{r}
dim(project)
```




```{r}
summary(project$E)
```

```{r, fig.width=12}
plotDensities(project, legend=FALSE)
```

### generate QC plots of raw intensities

```{r}
dir.create('QC/')
```



```{r}
boxplot(log2(project$E),range=0,ylab="log2 intensity")
```




```{r}
# for BeadArrays, background correction and normalisation are handled by a single function: neqc()
# this is the same as per Agilent single colour arrays
#
# perform background correction on the fluorescent intensities
#   'normexp' is beneficial in that it doesn't result in negative values, meaning no data is lost
#   for ideal offset, see Gordon Smyth's answer, here: https://stat.ethz.ch/pipermail/bioconductor/2006-April/012554.html
# normalize the data with the 'quantile' method, to be consistent with RMA for Affymetrix arrays

#Background correction / normalisation
project.bgcorrect.norm <- neqc(project)

```




```{r}
# filter out control probes, those with no symbol, and those that failed
annot <- annot[which(annot$Probe_Id %in% rownames(project.bgcorrect.norm)),]

project.bgcorrect.norm <- project.bgcorrect.norm[which(rownames(project.bgcorrect.norm) %in% 
                                                         annot$Probe_Id),]
annot <- annot[match(rownames(project.bgcorrect.norm), annot$Probe_Id),]

project.bgcorrect.norm@.Data[[3]] <- annot
project.bgcorrect.norm$genes <- annot

```



```{r}

table(project.bgcorrect.norm$genes$Source)

```



```{r}
boxplot(log2(project.bgcorrect.norm$E),range=0,ylab="log2 intensity")
```




```{r}
plotMDS(project.bgcorrect.norm,labels=targetinfo$Group)
```


## filtering

```{r}
Control <- project.bgcorrect.norm$genes$Source=="ILMN_Controls"
NoSymbol <- project.bgcorrect.norm$genes$Symbol == ""
isexpr <- rowSums(project.bgcorrect.norm$other$detection <= 0.05) >= 2

project.bgcorrect.norm.filt <- project.bgcorrect.norm[!Control & !NoSymbol & isexpr, ]
dim(project.bgcorrect.norm)
```



```{r}
dim(project.bgcorrect.norm.filt)
```




```{r}
table(Control)

table(NoSymbol)

table(isexpr)
```




```{r}
# remove annotation columns we no longer need
project.bgcorrect.norm.filt$genes <- project.bgcorrect.norm.filt$genes[,c(
    'Probe_Id',
    'Definition','Ontology_Component','Ontology_Process','Ontology_Function',
    'Chromosome','Probe_Coordinates','Cytoband','Probe_Chr_Orientation',
    'RefSeq_ID','Entrez_Gene_ID','Symbol')]


head(project.bgcorrect.norm.filt$genes)
```




```{r}
# summarise across genes by mean
# ID is used to identify the replicates
project.bgcorrect.norm.filt.mean <- avereps(project.bgcorrect.norm.filt, ID = project.bgcorrect.norm.filt$genes$Symbol)

dim(project.bgcorrect.norm.filt.mean)

```



```{r}

design<- model.matrix(~0 + targetinfo$Group)

## the column names are a bit ugly, so we will rename
colnames(design) <- c("Adjacent_non_tumor","Lung_Adenocarcinoma")


fit <- lmFit(project.bgcorrect.norm.filt.mean, design)

```




```{r}
hist(fit$Amean)
```




```{r}
plotSA(fit)
```



```{r}
contrasts<-makeContrasts(Lung_Adenocarcinoma - Adjacent_non_tumor,levels = design)

fit2 <- contrasts.fit(fit, contrasts)

#Finally, apply the empirical Bayesâ€™ step to get our differential expression statistics and p-values.

fit2 <- eBayes(fit2)

topTable(fit2)
```




```{r}
#If we want to know how many genes are differentially-expressed overall we can use the decideTests function.

results <- decideTests(fit2)
vennDiagram(results)

```



```{r}
summary(results)
```



## Further processing and visualisation of DE results

```{r}
rownames(annot) <- annot$Probe_Id
annot

```




```{r}
anno <- select(annot,Symbol,Entrez_Gene_ID,Chromosome,Cytoband)

fit2$genes <- anno

topTable(fit2)
```




```{r}
full_results <- topTable(fit2, number=Inf)
full_results <- tibble::rownames_to_column(full_results,"ID")
```



```{r}
## Make sure you have ggplot2 loaded
library(ggplot2)
ggplot(full_results,aes(x = logFC, y=B)) + geom_point()
```



```{r}
## change according to your needs
p_cutoff <- 0.05
fc_cutoff <- 2

full_results %>% 
  mutate(Significant = adj.P.Val < p_cutoff, abs(logFC) > fc_cutoff ) %>% 
  ggplot(aes(x = logFC, y = B, col=Significant)) + geom_point()
```




```{r}
####SA
plotSA(fit2, main="Final model: Mean-variance trend")

```

########### 

##### MA plots

Originally these MA plots were developed for two-color arrays to detect differences between the two color labels on the same array, and for these arrays they became hugely popular. This is why more and more people are now also using them for Affymetrix arrays but on Affymetrix only use a single color label. So people started using them to compare each Affymetrix array to a pseudo-array. The pseudo array consists of the median intensity of each probe over all arrays.

The MA plot shows to what extent the variability in expression depends on the expression level (more variation on high expression values?). In an MA-plot, A is plotted versus M:

M is the difference between the intensity of a probe on the array and the median intensity of that probe over all arrays M = logPMInt_array -- logPMInt_medianarray

A is the average of the intensity of a probe on that array and the median intesity of that probe over all arrays A = (logPMInt_array + logPMInt_medianarray)/2

```{r}
plotMD(fit2, status=results)
```

Ideally, the cloud of data points in the MA-plot should be centered around M=0 (blue line). This is because we assume that the majority of the genes is not DE and that the number of upregulated genes is similar to the number of downregulated genes. Additionally, the variability of the M values should be similar across different array-medianarray combinations. You see that the spread of the point cloud increases with the average intensity: the loess curve (red line) moves further and further away from M=0 when A increases. To remove (some of this) dependency, we will normalize the data.

##### from neqc

```{r, fig.width=12}
plotDensities(project.bgcorrect.norm.filt, legend=FALSE)
```



```{r}
average <- median(project.bgcorrect.norm.filt$E)
is_expressed <- project.bgcorrect.norm.filt$E > average

## Identify genes expressed in more than 2 samples
keep <- rowSums(is_expressed) > 2

## check how many genes are removed / retained.
table(keep)

## subset to just those expressed genes
gse <- project.bgcorrect.norm.filt[keep,]

dim(gse)

aw <- arrayWeights(gse, design)
fit_gse <- lmFit(gse, design, weights = aw)
contr_gse_fit_ebayes <- eBayes(contrasts.fit(fit_gse, contrasts))

volcanoplot(contr_gse_fit_ebayes)

```




```{r}
smoothScatter(contr_gse_fit_ebayes$Amean, contr_gse_fit_ebayes$coefficients, xlab = "averge intensity", ylab = "log-ratio")
abline(h = 0, col=2, lty=2)
```



```{r}
barplot(aw, xlab="Array", ylab="Weight", col="white", las=2)
abline(h=1, lwd=1, lty=2)
```




```{r}
summary(decideTests(contr_gse_fit_ebayes))
```
